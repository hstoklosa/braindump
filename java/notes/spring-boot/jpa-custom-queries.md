# [ðŸ”— Spring Data JPA @Query](https://www.baeldung.com/spring-data-jpa-query)

## Table of Contents

**Spring Data JPA @Query**

1. [Overview](#overview)
2. [Select Query](#select-query)

   2.1. [JPQL](#jpql)

   2.2. [Native SQL](#native-sql)

3. [Define Order in a Query](#define-order-in-a-query)

   3.1. [Sorting for JPA Provided and Derived Methods](#sorting-for-jpa-provided-and-derived-methods)

   3.2. [JPQL](#jpql-1)

   3.3. [Native SQL](#native-sql-1)

4. [Joining Tables in a Query](#joining-tables-in-a-query)

   4.1. [JPQL](#jpql-2)

   4.2. [Native SQL](#native-sql-2)

5. [Pagination](#pagination)

   5.1. [JPQL](#jpql-3)

   5.2. [Native SQL](#native-sql-3)

6. [Indexed Query Parameters](#indexed-query-parameters)

   6.1. [JPQL](#jpql-4)

   6.2. [Native SQL](#native-sql-4)

7. [Named Parameters](#named-parameters)

   7.1. [JPQL](#jpql-5)

   7.2. [Native SQL](#native-sql-5)

8. [Collection Parameter](#collection-parameter)

9. [Update Queries with @Modifying](#update-queries-with-modifying)

   9.1. [JPQL](#jpql-6)

   9.2. [Native SQL](#native-sql-6)

   9.3. [Inserts](#inserts)

10. [Dynamic Query](#dynamic-query)

    10.1. [Example of a Dynamic Query](#example-of-a-dynamic-query)

    10.2. [Custom Repositories and JPA Criteria API](#custom-repositories-and-jpa-criteria-api)

    10.3. [Extending the Existing Repository](#extending-the-existing-repository)

    10.4. [Using the Repository](#using-the-repository)

11. [Resources](#resources)

## Overview

`@Query` annotation is one of the ways to define an executable query within a Spring Data JPA repository.

`@Query` annotation can be used to execute both JQPL and native SQL queries.

## Select Query

Annotate a method in Spring Data repository with `@Query` where its value attribute contains the JPQL/SQL to execute.

`@Query` takes [precedence over/binds more tightly than] named queries i.e., queries annotated with `@NamedQuery` or defined in an `orm.xml` file.

The recommended practice is to place a query definition above a repository method rather than using a named query inside a domain model, because repository is responsible for handling the persistance in our application.

### JPQL

_**The query definition uses JQPL by default.**_

```java
@Query("SELECT u FROM User u WHERE u.status = 1")
Collection<User> findAllActiveUsers();
```

### Native SQL

To use native SQL, set the nativeQuery attribute to `true` in the `@Query` annotation.

```java
@Query(
    value = "SELECT * FROM USERS u WHERE u.status = 1",
    nativeQuery = true
)
Collection<User> findAllActiveUsersNative();
```

## Define Order in a Query

The method declarations in Spring Data with `@Query` annotations accept a parameter of type `Sort` that is translated into an `ORDER BY` clause (in the SQL query that's passed to the database).

### Sorting for JPA Provided and Derived Methods

For the methods that are generated by parsing method signatures, the sorting is done by the JPA provider.

```java
userRepository.findAll(Sort.by(Sort.Direction.ASC, "name"));

/*
 * This throws an exception:
 * "org.springframework.data.mapping.PropertyReferenceException: No property LENGTH(name) found for type User!"
 */
userRepository.findAll(Sort.by("LENGTH(name)"));
```

### JPQL

When using JPQL for a query definition, then Spring Data can handle sorting by simply adding a method parameter of type `Sort`.

```java
@Query(value = "SELECT u FROM User u")
List<User> findAllUsers(Sort sort);
```

Passing a sort parameter, which will order the result by the _name_ property of the _User_ entity.

```java
userRepository.findAllUsers(Sort.by("name"));
```

Since @Query is used, the same method can be used to get a sorted list of _Users_ by the length of their names.

```java
userRepository.findAllUsers(JpaSort.unsafe("LENGTH(name)"));
```

> The `JpaSort.unsafe()` is crucial when creating a _Sort_ object instance to avoid receiving the exception mentioned above.
>
> Spring Data discovers the unsafe `Sort` that uses the `@Query` annotation, and appends the sort clause to the query (it skips checking whether property belongs to the entity).

### Native SQL

When `@Query` uses native SQL, then sorting with `Sort` is not possible.

```java
org.springframework.data.jpa.repository.query.InvalidJpaQueryMethodException: Cannot use native queries with dynamic sorting and/or pagination
```

## Joining Tables in a Query

Multiple ways to define the select clause whenb handling columns from multiple tables.

Explicitly joining an entity with its related entities can resolve the N+1 query problem by ensuring they're fetched in one database trip.

### JPQL

It is necessary to define projections/DTOs to return the required fields from the joining tables.

```java
@Query(value = "SELECT new ResultDTO(c.id, o.id, p.id, c.name, c.email, o.orderDate, p.productName, p.price) "
    + " FROM Customer c, CustomerOrder o ,Product p "
    + " WHERE c.id=o.customer.id "
    + " AND o.id=p.customerOrder.id "
    + " AND c.id=?1 "
)
List<ResultDTO> findResultDTOByCustomer(Long id);
```

where _DTO_ and _ResultDTO_ are defined as:

```java
class DTO {
    private Long customer_id;
    private Long order_id;
    private Long product_id;

    public DTO(Long customer_id, Long order_id, Long product_id) {
        this.customer_id = customer_id;
        this.order_id = order_id;
        this.product_id = product_id;
    }
}

@Entity
@IdClass(DTO.class)
public class ResultDTO {
    @Id private Long customer_id;
    @Id private Long order_id;
    @Id private Long product_id;
    private String customerName;
    private String customerEmail;
    private LocalDate orderDate;
    private String productName;
    private Double productPrice;

    // getters, setters, constructors etc
}
```

> `ResultDTO` has a Composite PK which is defined in a separate class `DTO` and referenced via `@IdClass` annotation.
>
> This is only required when the repository method returns a _DTO_ with _Id_ as composite keys.

### Native SQL

Instead of specifying a subset of columns to be selected for the objects in the select clause, it is required to create repository methods like:

```java
@Query(value = "SELECT c.*, o.*, p.* "
    + " FROM Customer c, CustomerOrder o, Product p "
    + " WHERE c.id=o.customer_id "
    + " AND o.id=p.customerOrder_id "
    + " AND c.id=?1 ",
    nativeQuery = true
)
List<Map<String, Object>> findByCustomer(Long id);
```

> The keys corrsepond to the column names in the nativeQuery, and the list itself corresponds to the list of objecets returned by the method.
>
> There's no need to create _DTO_ classes, however, `nativeQuery` fetches all columns from all the tables being joined in the `@Query` annotation.

## Pagination

Pagination allows us to return just a subset of a whole result in a Page.

Also, the amount of data sent from server to client is minimized. By sending smaller pieces of data, we can generally see an improvement in performance.

### JPQL

Pass a `PageRequest` parameter to get a page of data.

```java
@Query(value = "SELECT u FROM User u ORDER BY id")
Page<User> findAllUsersWithPagination(Pageable pageable);
```

### Native SQL

Pagination for native queries requires to declare an additional attribute `countQuery` in the `@Query` annotation.

```java
@Query(
    value = "SELECT * FROM Users ORDER BY id",
    countQuery = "SELECT count(*) FROM Users",
    nativeQuery = true
)
Page<User> findAllUsersWithPagination(Pageable pageable);
```

## Indexed Query Parameters

2 ways of passing method parameters to a query: indexed and named parameters.

### JPQL

Spring Data JPA will pass method parameters to the query in the same order they appear in the method signature.

```java
@Query("SELECT u FROM User u WHERE u.status = ?1")
User findUserByStatus(Integer status);

@Query("SELECT u FROM User u WHERE u.status = ?1 and u.name = ?2")
User findUserByStatusAndName(Integer status, String name);
```

### Native SQL

It works the same exact way as JPQL.

```java
@Query(
    value = "SELECT * FROM Users u WHERE u.status = ?1",
    nativeQuery = true
)
User findUserByStatusNative(Integer status);
```

## Named Parameters

Passing method parameters to the query using named parameters.

Each parameter annotated with @Param must have a string value that matches the parameter name in the JPQL/SQL query.

### JPQL

Use `@Param` annotation to match parameters defined by name in JPQL with the method parameters.

```java
@Query("SELECT u FROM User u WHERE u.status = :status and u.name = :name")
User findUserByStatusAndNameNamedParams(
    @Param("status") Integer status,
    @Param("name") String name
);
```

It is not required for SQL query and method parameters to have the same name as long as the value string are the same.

```java
@Query("SELECT u FROM User u WHERE u.status = :status and u.name = :name")
User findUserByUserStatusAndUserName(
    @Param("status") Integer userStatus,
    @Param("name") String userName
);
```

### Native SQL

No difference compared to passing named parameters in JPQL.

```java
@Query(
    value = "SELECT * FROM Users u WHERE u.status = :status and u.name = :name",
    nativeQuery = true
)
User findUserByStatusAndNameNamedParamsNative(
    @Param("status") Integer status,
    @Param("name") String name
);
```

## Collection Parameter

_**CASE:**_ The _WHERE_ clause of a JPQL/SQL query contains either _IN_ or _NOT IN_ operator.

To handle this case, define a query that takes Collection as a parameter (can be used with `List`, `HashSet` etc).

```java
SELECT u FROM User u WHERE u.name IN :names

@Query(value = "SELECT u FROM User u WHERE u.name IN :names")
List<User> findUserByNameList(@Param("names") Collection<String> names);
```

## Update Queries with @Modifying

The `@Query` annotation can be used to modify the values in a database by combining it with the `@Modifying` annotation in the repository method.

### JPQL

The repository method now uses both `@Query` and `@Modifying` annotations, and the query uses _UPDATE_ instead of the _SELECT_ statement.

```java
@Modifying
@Query("UPDATE User u SET u.status = :status WHERE u.name = :name")
int updateUserSetStatusForName(
    @Param("status") Integer status,
    @Param("name") String name
);
```

### Native SQL

Same process as above.

```java
@Modifying
@Query(
    value = "UPDATE Users u SET u.status = ? WHERE u.name = ?",
    nativeQuery = true
)
int updateUserSetStatusForNameNative(Integer status, String name);
```

### Inserts

Performing _INSERT_ operations requires a native query with the `@Modifying` annotation, since [_INSERT_ is not part of the JPA interface](https://www.baeldung.com/jpa-insert).

```java
@Query(
    value = "INSERT INTO Users (name, age, email, status) VALUES (:name, :age, :email, :status)",
    nativeQuery = true
)
@Modifying
void insertUser(
    @Param("name") String name,
    @Param("age") Integer age,
    @Param("status") Integer status,
    @Param("email") String email
);
```

## Dynamic Query

Often we need to build SQL statements based on conditions/datasets whose values are not known at compile time, but at runtime.

Static queries won't work in this case.

### Example of a Dynamic Query

A set of email addresses i.e., email_1, email_2, ..., email_n constructed at runtime.

```java
SELECT u FROM User u WHERE u.email LIKE '%email1%'
    or  u.email LIKE '%email2%'
    ...
    or  u.email LIKE '%emailn%'
```

The `@Query` annotation can't be used since we providing a static SQL statement isn't possible.

Instead, by implementing a custom composite repository, we can extend the base JpaRepository functionality and provide own logic for building a dynamic query.

### Custom Repositories and JPA Criteria API

_**Spring provides a way for extending the base repository through the use of custom fragment interfaces.**_

Those can be linked together to create a [composite repository](https://www.baeldung.com/spring-data-composable-repositories).

The [JPA Criteria API](https://www.baeldung.com/hibernate-criteria-queries) is also leveraged to build dynamic queries.

```java
public interface UserRepositoryCustom {
    List<User> findUserByEmails(Set<String> emails);
}

public class UserRepositoryCustomImpl implements UserRepositoryCustom {

    @PersistenceContext
    private EntityManager entityManager;

    @Override
    public List<User> findUserByEmails(Set<String> emails) {
        CriteriaBuilder cb = entityManager.getCriteriaBuilder();
        CriteriaQuery<User> query = cb.createQuery(User.class);
        Root<User> user = query.from(User.class);

        Path<String> emailPath = user.get("email");

        List<Predicate> predicates = new ArrayList<>();
        for (String email : emails) {
            predicates.add(cb.like(emailPath, email));
        }
        query.select(user)
            .where(cb.or(predicates.toArray(new Predicate[predicates.size()])));

        return entityManager.createQuery(query)
            .getResultList();
    }
}
```

> Ensure to include the _Impl_ postfix in the class name, since Spring relies on this mechanism to find the fragment implementation.

### Extending the Existing Repository

```java
public interface UserRepository extends JpaRepository<User, Integer>, UserRepositoryCustom {
    // query methods from section 2 - 7
}
```

### Using the Repository

```java
// Filling the set with any number of items
Set<String> emails = new HashSet<>();
/* .
 * .
 * .
 * .
 */
userRepository.findUserByEmails(emails);
```

## Resources

- [Spring Data JPA @Query](https://www.baeldung.com/spring-data-jpa-query)

- [Optimizing Queries with @Query Annotation](https://medium.com/@AlexanderObregon/optimizing-queries-with-query-annotation-in-spring-data-jpa-fe213c8a60a)
